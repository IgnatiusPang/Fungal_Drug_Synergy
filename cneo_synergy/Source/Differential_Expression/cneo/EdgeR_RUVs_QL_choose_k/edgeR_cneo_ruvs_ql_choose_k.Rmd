---
title: "edgeR_cneo_ruvs_ql_choose_k.Rmd"
author: "Ignatius Pang"
output:
  html_document: default
  html_notebook: default
---

# Differential Gene Expression Analysis Using Edge R

Analysis of the effect of voriconazole and EDTA on C. neoformans as compared to controls. 

```{r}
## try http:// if https:// URLs are not supported
# source("https://bioconductor.org/biocLite.R")
# biocLite("RUVSeq")
```


## Load libraries and scripts
```{r}

if(!require(pacman)) {
  install.packages("pacman")
  library(pacman)
}

p_load(tidyverse)
p_load(edgeR)
p_load(limma)
p_load(mixOmics)
p_load(RUVSeq)
p_load(EDASeq)
p_load(RColorBrewer)
p_load(lazyeval)
		
source( '../Common/edgeR_common_functions.R')
source( '../../../Common/global_parameters.R')
source( '../../../Common/helper_functions.R')

sessionInfo()

```

## Command-line parameters
```{r}

command_line_args <-  commandArgs(trailingOnly=T)

print( command_line_args)

if ( length(command_line_args) > 0   ) {
	##### This is a parameter to change #### *******************
	num_unwanted_variables <- as.integer( command_line_args[2]    ) 
	
	##### This is a parameter to change #### *******************
	is_quasi_likelihood_test <- as.logical( command_line_args[3]  )
	
	##### This is a parameter to change #### *******************
	type_of_ruv <-  as.character( command_line_args[4]  ) # RUVg, RUVs, RUVr
	
	##### This is a parameter to change #### *******************
	organism <-  as.character( command_line_args[5]  ) # 
		
} else {
	
	num_unwanted_variables <- 5
	
	is_quasi_likelihood_test <- TRUE
	
	type_of_ruv <-  "RUVs"
	
	organism <- "cneo"
		
}
	



if( !(type_of_ruv %in% c( "RUVg", "RUVs", "RUVr"))) {
	stop( "Type of RUV chosen is not valid.")
}

```

## Global parameters
```{r}

 
min_count <- 1 # threshold cpm for a gene
num_samples_above_cutoff <- 6 # At least this many column above minimum count
normalization_method <- "upperquartile"
normalization_method_between_lane <- "upper"

```


## Directory Management
```{r}

type_of_hypothesis_test <- ifelse(  is_quasi_likelihood_test, "QL", "LRT")

 num_samples_dir <- "All_Samples"

if( "5a" %in% samples_to_remove) {
  
  num_samples_dir <- "Remove_5a"
} 

choose_k_results_directory <- file.path(results_directory, "Differential_Expression",  
										paste(  "EdgeR",  type_of_ruv,  type_of_hypothesis_test, sep="_" ),  
										organism , 
										num_samples_dir, 
										paste("k_", num_unwanted_variables, sep="") ) 

create_directory_if_not_exists( choose_k_results_directory ) 

```

## Load design matrix
```{r}

design_matrix <- read.table(cneo_design_matrix_file, header=TRUE, sep="\t", stringsAsFactors = TRUE)

biological_replicates <- c( "1", "2", "3" )
names( biological_replicates) <- as.character( sort( as.Date( unique(  design_matrix$Date ), format = "%d/%m/%Y") ))



as.character(design_matrix$Date)

design_matrix <- design_matrix %>%
				 dplyr::mutate( Biological_Replicate = biological_replicates[  as.character(  as.Date( design_matrix$Date , format = "%d/%m/%Y") )] )

design_matrix <- design_matrix %>%
				 dplyr::mutate( Short_Name = paste(Experiment , Biological_Replicate, sep="") )

## Remove sample 5a

design_matrix <- design_matrix %>%
                  filter( ! (Sample %in% samples_to_remove ) )  

```

## Hash tables for design matrix 
```{r}

short_names <- purrr::map_chr(design_matrix$Sample, function(x) { paste( "X", toupper(x), sep="") } )
map_long_to_short_experiment_name <- create_id_to_attribute_hash ( short_names , design_matrix$Short_Name) 
map_short_name_to_treatment_type  <- create_id_to_attribute_hash (  design_matrix$Short_Name, design_matrix$Experiment ) 
map_short_name_to_expt_group      <- create_id_to_attribute_hash (  design_matrix$Short_Name, design_matrix$Experiment ) 

```

## Read in the file and calculate normalisation factor 
```{r}


samples_counts <- read.table(cneo_read_counts_file, header=TRUE)
rownames(samples_counts) <- samples_counts[, "orf_id"]
samples_counts <- samples_counts[,2:length(samples_counts[1,])]

to_remove_short_names <- purrr::map_chr(samples_to_remove, function(x) { paste( "X", toupper(x), sep="") } )

samples_counts <- samples_counts[ , !( colnames(samples_counts)  %in% to_remove_short_names ) ]

# Convert long name to short experiment name 
short_names <- map_chr ( colnames(samples_counts), function(key) {  convert_key_to_attribute (key, map_long_to_short_experiment_name) } )
colnames( samples_counts) <- short_names
samples_counts <- samples_counts[, sort(colnames( samples_counts))]

## Remove sample 5a

## Fix up ordering of design matrix and sample_counts
rownames(design_matrix) <- design_matrix$Short_Name
design_matrix <- design_matrix[colnames(samples_counts),]

purrr::map_chr( design_matrix$Sample , ~paste( "X", toupper(.), sep="" )) == colnames( samples_counts[,2:(ncol(samples_counts))])

if ( any( colnames(samples_counts) != rownames(design_matrix) ) ) {
	stop ( "Problem with consistency between the column names of counts table and design matrix.")
}

# Pre-filtering
genes_to_keep <- apply( cpm(samples_counts), 1, function(x) length(x[ x > min_count]) >= num_samples_above_cutoff )
# genes_to_keep_2 <- rowSums( samples_counts   >= min_count) >= num_samples_above_cutoff

length(which(genes_to_keep))
# length(which(genes_to_keep_2))
samples_counts <- samples_counts[genes_to_keep, ]

# Create dgelist object
cneo_dgelist <- DGEList(counts=samples_counts, genes=rownames(samples_counts) )


# Calculate normalisation factor
cneo_dgelist <- calcNormFactors(cneo_dgelist, method=normalization_method)
```
	
## Set Model Matrix	
```{r}
design <- model.matrix(~0 + design_matrix$Experiment + 
					   	design_matrix$Lane + 
					   	design_matrix$Biological_Replicate, data=design_matrix)

colnames( design)  <- c( levels(design_matrix$Experiment ), "LaneL2", "Biological_Replicate2", "Biological_Replicate3" ) 
rownames( design)  <- design_matrix$Sample

```

## log raw counts plot 
```{r}

logcounts <- log2(samples_counts+0.1)

treatment_type_list <- map_chr ( colnames( samples_counts), function(key){ convert_key_to_attribute(key, map_short_name_to_treatment_type) })
expt_group_list <- map_chr ( colnames( samples_counts), function(key){ convert_key_to_attribute(key, map_short_name_to_expt_group) })

group.colours <- c('slateblue','orange')[as.numeric(as.factor(treatment_type_list))];
# par(mar=c(5.1, 5, 4.1, 7), xpd=TRUE)
boxplot(logcounts,
		col=group.colours,
		main="Distribution of log counts",
		xlab="",
		ylab="Log2(raw counts+0.1)",
		las=2,cex.axis=0.8)

legend("topright", # inset=c(-0.2,0), cex = 0.8,
		legend = levels(as.factor(design_matrix$Experiment)),
		fill = unique(group.colours))

```

## Run normalisation
```{r}
# voom_output <- voom(cneo_dgelist, design)
# norm.expr <- voom_output$E

cneo_dgelist <- estimateGLMCommonDisp(cneo_dgelist, design, verbose=TRUE)
cneo_dgelist <- estimateGLMTrendedDisp(cneo_dgelist, design)
cneo_dgelist <- estimateGLMTagwiseDisp(cneo_dgelist, design)

norm.expr <- cpm(cneo_dgelist, log=TRUE)


write.table(norm.expr, file=file.path(choose_k_results_directory, "edger_without_ruvs_normalised_counts.txt"),
						row.names=T, quote=F, sep="\t")
```

## log normalized counts plot 
```{r}
boxplot( norm.expr,
col=group.colours,
main="Distribution of normalised counts",
xlab="",
ylab="log2 normalised expression",
las=2,cex.axis=0.8)

```

## Heat map of samples correlation after normalisation
```{r}
 heatmap ( 1 - cor (norm.expr, method="spearman" ),scale="none" )

```


## PCA plots
```{r}

norm.expr.df <- t(norm.expr)
dim(norm.expr.df)

## check if any feature has 0 variance, if so might need to remove
colVar <- apply(norm.expr.df,2,var)
length(which(colVar==0))

tuning <- tune.pca(norm.expr.df, center=TRUE, scale=TRUE)


pca.result <- pca(norm.expr.df, ncomp=3, center=T, scale=T)

plotIndiv(pca.result, comp=c(1,2) , group=treatment_type_list, title="PCA: Colour by treatment type")
plotIndiv(pca.result, comp=c(1,2) , group=expt_group_list, 
		  title="PCA: Colour by treatment type and time point")

```

## Using a subset of genes for pca
```{r}
subset_of_genes_for_pca <- names( sort( abs( pca.result$loadings$X[, "PC1"] ), decreasing = TRUE )[1:1000] )

norm.expr.df <- t(norm.expr[subset_of_genes_for_pca, ])
dim(norm.expr.df)

## check if any feature has 0 variance, if so might need to remove
colVar_ruv <- apply(norm.expr.df,2,var)
length(which(colVar_ruv==0))

tuning <- tune.pca(norm.expr.df, center=TRUE, scale=TRUE)

pca.result <- pca(norm.expr.df, ncomp=3, center=T, scale=T)

plotIndiv(pca.result, comp=c(1,2) , group=treatment_type_list, title="PCA: Colour by treatment type")
plotIndiv(pca.result, comp=c(1,2) , group=expt_group_list, 
		  title="PCA: Colour by treatment type and time point")

```


## ANOVA test of any differential gene expression to get empirical control genes 
```{r}


design_pre_ruv <- model.matrix( ~ design_matrix$Experiment , data=design_matrix)

design_for_ruv <- model.matrix( ~ 0 + design_matrix$Experiment , data=design_matrix)

## Assign the expression set
input_data <- as.matrix(samples_counts)
input_data <- input_data[, design_matrix$Short_Name ]
set <- newSeqExpressionSet( input_data, 
						    phenoData=data.frame(design_for_ruv, row.names= rownames(design_for_ruv)  )) 

set <- betweenLaneNormalization(set, which=normalization_method_between_lane)

y <- DGEList(counts=counts(set), group=design_matrix$Experiment )
y <- calcNormFactors(y, method=normalization_method)
y <- estimateGLMCommonDisp(y, design_pre_ruv)
y <- estimateGLMTrendedDisp(y, design_pre_ruv)
y <- estimateGLMTagwiseDisp(y, design_pre_ruv)

cneo_fit <-  NULL
lrt <- NULL
if ( is_quasi_likelihood_test == TRUE) {
	cneo_fit <- glmQLFit( y , design_pre_ruv)
	lrt <- glmQLFTest(cneo_fit, coef=2:ncol(cneo_fit$design))

} else {
	cneo_fit <- glmFit( y , design_pre_ruv)
	lrt <- glmLRT(cneo_fit, coef=2:ncol(cneo_fit$design))
}

top <- topTags(lrt, n=nrow(y), sort.by="p.value")$table
empirical <- rownames(y)[which(!(rownames(y) %in% 
 												rownames(top)[1:5000]) ) ]


res <- residuals(cneo_fit, type="deviance")

differences <- makeGroups(design_matrix$Experiment)


```

```{r}
hist( top[, "PValue"] )
length ( which ( top[, "FDR"] <0.05 ))

## Default to RUVs

set2 <- NULL
 if  ( type_of_ruv == "RUVs") {
	set2 <- RUVs(set, rownames( set@assayData$counts), k=num_unwanted_variables, differences)
} else if  ( type_of_ruv == "RUVr") {
	set2 <- RUVr(set, rownames( set@assayData$counts), k=num_unwanted_variables, res)
} else if (type_of_ruv == "RUVg") {
	set2 <- RUVg(set, empirical, k=num_unwanted_variables, res)
}

plot_RLE_before_and_after_ruv_version_edgeR( set, set2, 
											 "After upper quartile normalisation but no batch effects removal", 
											  "After upper quartile normalisation + RUVs", expt_group_list, treatment_type_list,
											 choose_k_results_directory,
											 "before_and_after_RLE_plots.pdf")

```

## Apply RUV correction
```{r}

ruvs_design <- pData(set2)

unwanted_factors_vector <- purrr::map_chr ( 1:num_unwanted_variables,  function(x) { paste( "W_", x, sep="") } )

colnames( ruvs_design) <- c( levels(design_matrix$Experiment), unwanted_factors_vector ) 

saveRDS( ruvs_design, file=file.path( choose_k_results_directory, "ruvs_design_matrix.Rdata") ) 

equation_string <- paste( "~ 0 + A + CA + AL + CAL + " , 
						  paste( unwanted_factors_vector, collapse=" + "), sep=" + ") 


 ruvs_design <- model.matrix(  formula(uq(equation_string )), data=ruvs_design )


cneo_deg_ruv <- DGEList(counts=counts(set2))
cneo_deg_ruv <- calcNormFactors(cneo_deg_ruv,  method=normalization_method)
cneo_deg_ruv <- estimateGLMCommonDisp(cneo_deg_ruv, ruvs_design)
cneo_deg_ruv <- estimateGLMTrendedDisp(cneo_deg_ruv, ruvs_design)
cneo_deg_ruv <- estimateGLMTagwiseDisp(cneo_deg_ruv, ruvs_design)

plotBCV(cneo_deg_ruv)

png( file = file.path( choose_k_results_directory, "edger_ruvs_bcv_plot.png"))
plotBCV(cneo_deg_ruv)
dev.off()

saveRDS( cneo_deg_ruv, file=file.path( choose_k_results_directory, "cneo_deg_ruv.Rdata") ) 


```


## RLE plot after calcNormFactors, RLE plot after calcNormFactors and adjusting for RUV
```{r}

calc.norm.expr <- cpm( cneo_deg_ruv, log=TRUE, prior.count = 2 )
 
plotMDS(calc.norm.expr, col=c("blue", "green")[as.numeric(as.factor(treatment_type_list))], main="RLE after calcNormFactors") 
plotRLE(calc.norm.expr, outline=FALSE, ylim=c(-0.1, 0.1), col=brewer.pal(6, "Set2")[as.numeric(as.factor(expt_group_list))], 
        main="RLE after calcNormFactors", las=3)

pdf(file = file.path( choose_k_results_directory, "RLE_after_calcNormFactors.pdf")) 
plotMDS(calc.norm.expr, col=c("blue", "green")[as.numeric(as.factor(treatment_type_list))], main="RLE after calcNormFactors") 
plotRLE(calc.norm.expr, outline=FALSE, ylim=c(-0.1, 0.1), col=brewer.pal(6, "Set2")[as.numeric(as.factor(expt_group_list))], 
        main="RLE after calcNormFactors", las=3)
dev.off()

# ruv.norm.expr <- cpm( set2@assayData$normalizedCounts, log=TRUE, prior.count = 2)
## Get the normalized read counts after RUVSeq

if ( length ( which ( colnames( calc.norm.expr) != rownames( ruvs_design) )) > 0 ) {
	stop ("Something terribly wrong with the matching of sample names in the counts table and the design matrix. ")
}

unwanted_factors_vector <- purrr::map_chr ( 1:num_unwanted_variables,  function(x) { paste( "W_", x, sep="") } )

ruv.norm.expr <- removeBatchEffect(calc.norm.expr, covariates=ruvs_design[,unwanted_factors_vector])

plotMDS(ruv.norm.expr, col=c("blue", "green")[as.numeric(as.factor(treatment_type_list))], main="RLE after calcNormFactors and adjusting for unwanted variaions") 
plotRLE(ruv.norm.expr, outline=FALSE, ylim=c(-0.1, 0.1), col=brewer.pal(6, "Set2")[as.numeric(as.factor(expt_group_list))], 
        main="RLE after calcNormFactors and adjusting for unwanted variaions", las=3)


pdf(file = file.path( choose_k_results_directory, "RLE_after_calcNormFactors_and_RUV.pdf")) 
plotMDS(ruv.norm.expr, col=c("blue", "green")[as.numeric(as.factor(treatment_type_list))], main="RLE after calcNormFactors and adjusting for unwanted variaions") 
plotRLE(ruv.norm.expr, outline=FALSE, ylim=c(-0.1, 0.1), col=brewer.pal(6, "Set2")[as.numeric(as.factor(expt_group_list))], 
        main="RLE after calcNormFactors and adjusting for unwanted variaions", las=3)
dev.off()

write.table(ruv.norm.expr, file=file.path(choose_k_results_directory, "edger_ruvs_log_normalised_counts_cpm.txt"),
						row.names=T, quote=F, sep="\t")

```

## PCA plot
```{r}


ruv.norm.expr.df <- t(ruv.norm.expr)
dim(ruv.norm.expr.df)

## check if any feature has 0 variance, if so might need to remove
colVar_ruv <- apply(ruv.norm.expr.df,2,var)
length(which(colVar_ruv==0))

tuning_ruv <- tune.pca(ruv.norm.expr.df, center=TRUE, scale=TRUE)

ruv.pca.result <- pca(ruv.norm.expr.df, ncomp=3, center=T, scale=T)

plotIndiv(ruv.pca.result, comp=c(1,2) , group=treatment_type_list, title="PCA: Colour by treatment type")
plotIndiv(ruv.pca.result, comp=c(1,2) , group=expt_group_list, 
		  title="PCA: Colour by treatment type and time point")

```


## Using a subset of genes for pca
```{r}
subset_of_genes_for_pca <- names( sort( abs( ruv.pca.result$loadings$X[, "PC1"] ), decreasing = TRUE )[1:1000] )


ruv.norm.expr.df <- t(ruv.norm.expr[subset_of_genes_for_pca, ])
dim(ruv.norm.expr.df)

## check if any feature has 0 variance, if so might need to remove
colVar_ruv <- apply(ruv.norm.expr.df,2,var)
length(which(colVar_ruv==0))

tuning_ruv <- tune.pca(ruv.norm.expr.df, center=TRUE, scale=TRUE)

ruv.pca.result <- pca(ruv.norm.expr.df, ncomp=3, center=T, scale=T)

plotIndiv(ruv.pca.result, comp=c(1,2) , group=treatment_type_list, title="PCA: Colour by treatment type")
plotIndiv(ruv.pca.result, comp=c(1,2) , group=expt_group_list, 
		  title="PCA: Colour by treatment type and time point")

```



